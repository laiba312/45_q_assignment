{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["const TOKENS = /(\\S+)|(.)/g;\nconst IS_SPECIAL_CASE = /[\\.#]\\p{L}/u; // #tag, example.com, etc.\nconst IS_MANUAL_CASE = /\\p{Ll}(?=[\\p{Lu}])/u; // iPhone, iOS, etc.\nconst ALPHANUMERIC_PATTERN = /[\\p{L}\\d]+/gu;\nconst IS_ACRONYM = /(?:\\p{Lu}\\.){2,}$/u;\n\nexport const WORD_SEPARATORS = new Set([\"—\", \"–\", \"-\", \"―\", \"/\"]);\n\nexport const SENTENCE_TERMINATORS = new Set([\n  \".\",\n  \"!\",\n  \"?\",\n  \":\",\n  '\"',\n  \"'\",\n  \"”\",\n]);\n\nexport const SMALL_WORDS = new Set([\n  \"a\",\n  \"an\",\n  \"and\",\n  \"as\",\n  \"at\",\n  \"because\",\n  \"but\",\n  \"by\",\n  \"en\",\n  \"for\",\n  \"if\",\n  \"in\",\n  \"neither\",\n  \"nor\",\n  \"of\",\n  \"on\",\n  \"only\",\n  \"or\",\n  \"over\",\n  \"per\",\n  \"so\",\n  \"some\",\n  \"than\",\n  \"that\",\n  \"the\",\n  \"to\",\n  \"up\",\n  \"upon\",\n  \"v\",\n  \"versus\",\n  \"via\",\n  \"vs\",\n  \"when\",\n  \"with\",\n  \"without\",\n  \"yet\",\n]);\n\nexport interface Options {\n  smallWords?: Set<string>;\n  sentenceTerminators?: Set<string>;\n  wordSeparators?: Set<string>;\n  locale?: string | string[];\n}\n\nexport function titleCase(\n  input: string,\n  options: Options | string[] | string = {},\n) {\n  let result = \"\";\n  let m: RegExpExecArray | null;\n  let isNewSentence = true;\n\n  const {\n    smallWords = SMALL_WORDS,\n    sentenceTerminators = SENTENCE_TERMINATORS,\n    wordSeparators = WORD_SEPARATORS,\n    locale,\n  } = typeof options === \"string\" || Array.isArray(options)\n    ? { locale: options }\n    : options;\n\n  // tslint:disable-next-line\n  while ((m = TOKENS.exec(input)) !== null) {\n    const { 1: token, 2: whiteSpace, index } = m;\n\n    if (whiteSpace) {\n      result += whiteSpace;\n      continue;\n    }\n\n    // Ignore URLs, email addresses, acronyms, etc.\n    if (IS_SPECIAL_CASE.test(token)) {\n      result += token;\n\n      // The period at the end of an acronym is not a new sentence.\n      if (IS_ACRONYM.test(token)) {\n        isNewSentence = false;\n        continue;\n      }\n    } else {\n      const matches = Array.from(token.matchAll(ALPHANUMERIC_PATTERN));\n      let value = token;\n\n      for (let i = 0; i < matches.length; i++) {\n        const { 0: word, index: wordIndex = 0 } = matches[i];\n\n        // Reset \"new sentence\" when we find a word.\n        if (isNewSentence) {\n          isNewSentence = false;\n        } else {\n          // Ignore small words except at beginning or end,\n          // or previous token is a new sentence.\n          if (\n            smallWords.has(word) &&\n            // Not the final token and word.\n            !(index + token.length === input.length && i === matches.length - 1)\n          ) {\n            continue;\n          }\n        }\n\n        if (IS_MANUAL_CASE.test(word)) {\n          continue;\n        }\n\n        // Only capitalize words after a valid word separator.\n        if (i > 0 && !wordSeparators.has(token.charAt(wordIndex - 1))) {\n          continue;\n        }\n\n        value =\n          value.slice(0, wordIndex) +\n          value.charAt(wordIndex).toLocaleUpperCase(locale) +\n          value.slice(wordIndex + 1);\n      }\n\n      result += value;\n    }\n\n    const lastChar = token.charAt(token.length - 1);\n    isNewSentence = sentenceTerminators.has(lastChar);\n  }\n\n  return result;\n}\n"]}